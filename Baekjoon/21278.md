### 호석이 두 마리 치킨

```python
import sys, itertools
from collections import deque
input = sys.stdin.readline

N, M = map(int, input().split())   # 건물 개수, 도로 개수
graph = [[]*(N+1) for _ in range(N+1)]
for _ in range(M):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

cases = list(itertools.combinations([i for i in range(1, N+1)], 2))   # 가능한 건물 번호
scores = []   # cases에 대응하는 건물까지의 거리
for case in cases:
    queue = deque()
    check = [0 for _ in range(N+1)]   # 방문 표시
    i, j = case
    queue.append([i, 0])
    queue.append([j, 0])
    check[i] = 1
    check[j] = 1

    distance = [0 for _ in range(N+1)]   # i 또는 j까지의 거리
    while queue:
        node, depth = queue.popleft()
        for next in graph[node]:   # node와 연결된 건물로 이동
            if not check[next]:
                check[next] = 1    # 방문 표시
                queue.append([next, depth+1])
        distance[node] = depth

    scores.append(distance)   # case의 각 노드에서 i 또는 j까지의 거리 list 추가

score = []   # 각 경우의 거리 합 저장
idx = 0      # 최단 시간이 걸리는 경우의 인덱스
min_v = 1e9
for i in range(len(scores)):
    score.append(sum(scores[i]))
    if sum(scores[i]) < min_v:   # 최단 시간을 찾았다
        min_v = sum(scores[i])
        idx = i                  # 인덱스 저장

print(*cases[idx], score[idx]*2)
```

